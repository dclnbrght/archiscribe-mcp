## ArchiScribe MCP - Development Plan

This document defines a detailed, sequenced development plan for the ArchiScribe MCP Server project described in `copilot/1.archiscribe.mcp.requirements.md`.

### Task receipt & approach
I will convert the requirements into a concrete, testable plan and checklist, then implement iteratively: scaffold project, implement core features (model loader, view search, view details), add configuration, generate markdown output, and create tests and docs. Each step has acceptance criteria and quality gates.

---

## Requirements (extracted)
All explicit requirements from the requirements file have been implemented and completed.

**Core Implementation Requirements:**
- Implement MCP Server in TypeScript/Node.js using the MCP Typescript SDK (`@modelcontextprotocol/sdk`)
- Project code in `src/` directory
- Use example files in `data/` for testing and demo (`archimate-scribe-demo-model.xml`, `archiscribe-Dataflow-view.md`)
- MCP tools: SearchViews & GetViewDetails

**API Requirements:**
- Provide API: "Search View Names" — returns list of view names optionally filtered by keyword and by configurable view property filter
- Provide API: "Get View Details" — returns detailed information about a view (elements and relationships)
- Return content in Markdown format

**Configuration Requirements:**
- Config settings: model file path/URL, `viewsFilterByProperty` (true/false), `viewsFilterPropertyName` (default `AI-Context`), `serverPort` (default 3030)

**Quality Requirements:**
- Create well-structured, testable code with unit & integration tests

## Assumptions
- The ArchiMate model is provided as an ArchiMate Exchange XML file located locally at `data/archimate-scribe-demo-model.xml`.
- The MCP Typescript SDK is suitable for wiring the MCP server, but a minimal HTTP API will be provided if SDK usage is optional during early iterations.
- Node >= 18 and npm/yarn available on the developer machine.

## High-level milestones

1. Project scaffolding & dependencies
2. Configuration system & environment handling
3. ArchiMate model loader & parser (XML -> in-memory model)
4. Implement core MCP endpoints (Search View Names, Get View Details)
5. Markdown renderer for view responses
6. Tests: unit tests for parser & renderer, integration tests for endpoints
7. Documentation, README, example usage
8. Minor improvements and hardening (error handling, edge cases)

## Detailed implementation plan (sequenced steps)

- [x] **1) Scaffolding and initial repo layout**
   - [x] Create `package.json`, TypeScript config (`tsconfig.json`), and basic scripts: `build`, `start`, `dev`, `test`.
   - [x] Directory layout under `src/`: `src/mcp`, `src/config`, `src/model`, `src/api`, `src/renderer`, `src/tests`.
   - [x] Add `data/` folder if not present and verify example files exist.
   - [x] Acceptance: project compiles, `npm run build` passes.

- [x] **2) Configuration**
   - [x] Implement a `Config` module that reads environment variables and a config file (e.g., `config/settings.json`) with defaults.
   - [x] Config fields: `modelPath`, `viewsFilterByProperty` (boolean), `viewsFilterPropertyName` (string, default `AI-Context`), `serverPort` (3030).
   - [x] Acceptance: `Config` unit test verifies defaults and overrides from env.

- [x] **3) ArchiMate model loader & parser**
   - [x] Implement `ModelLoader` to read the ArchiMate Exchange XML and parse to an in-memory representation (views, elements, relationships).
   - [x] Use `fast-xml-parser` and implement minimal mapping required for views and elements.
   - [x] Cache the parsed model and expose reload method.
   - [x] Acceptance: unit tests validate parsing of `data/archimate-scribe-demo-model.xml` into expected view names and counts.

- [x] **4) Markdown renderer**
   - [x] Implement modular renderer to convert model objects into markdown. Keep renderer separate from API to allow reuse.
   - [x] Acceptance: unit tests for renderer with small model fixtures.

- [x] **5) MCP Typescript SDK integration & tool implementations**
   - [x] Install and configure `@modelcontextprotocol/sdk` as a dependency. Create a `src/mcp` module to host MCP server wiring and tool implementations.
   - [x] Define two MCP tools that mirror the API operations:
       - [x] `SearchViews`: Input: { query?: string }, Output: { markdown: string }
       - [x] `GetViewDetails`: Input: { viewname: string }, Output: { markdown: string }
   - [x] Implement handler functions that call the `ModelLoader` and `Renderer` components.
   - [x] Expose an MCP server start/stop API in `src/mcp/server.ts` that registers the tools with the SDK.
   - [x] Provide an HTTP wrapper that translates HTTP requests into MCP tool invocations.
   - [x] Testing and acceptance: Unit test each tool handler, integration test MCP server functionality.

- [x] **6) API: Search View Names**
   - [x] Implement endpoint `GET /views?query=<keyword>` that returns a Markdown list of matched view names.
   - [x] Support optional filtering by the configured view property: when `viewsFilterByProperty` is true, only include views with the configured property name present.
   - [x] Response content-type: `text/markdown`.
   - [x] Acceptance: integration tests call endpoint and inspect markdown output.

- [x] **7) API: Get View Details**
   - [x] Implement `GET /views/:name` which returns a Markdown document containing view metadata, elements, and relationships.
   - [x] Markdown format follows the example structure in `data/archiscribe-Dataflow-view.md`.
   - [x] Acceptance: integration test compares output to expected structure.

- [x] **8) Testing**
   - [x] Unit tests (vitest) for Config, ModelLoader, Renderer.
   - [x] Integration tests for the two endpoints, using an in-memory server instance.
   - [x] MCP tools testing for SearchViews and GetViewDetails.
   - [x] Meaningful test coverage focusing on core logic.

- [x] **9) Documentation & README**
   - [x] Document how to run, configuration options, and examples using the sample files.
   - [x] Include MCP tool descriptions and HTTP API documentation.
   - [x] Add installation and development setup instructions.

## Data contract / small design notes
- Model shape (minimal):
  - View: { id, name, type, documentation?, properties: { [k]: v }, elements: [elementId], relationships: [relId] }
  - Element: { id, name, type, documentation?, properties }
  - Relationship: { id, sourceId, targetId, type, name }

## Edge cases to handle
- Missing or unreadable model file
- Malformed XML
- Views with duplicate names
- Views that contain no elements
- Large models (ensure reasonable memory usage and caching)

## Tests (minimal set to create first)
- Unit: Config default/override (happy & missing env)
- Unit: ModelLoader parses sample XML, returns known view names
- Unit: Renderer produces markdown sections for view with elements
- Integration: Start server with sample model; call `/views?query=` and `/views/:id` and assert HTTP 200 and markdown content

## Acceptance criteria and success definition
- Server builds and starts (port configurable) and responds to the two endpoints.
- Responses are human-readable markdown and include the requested data.
- Tests pass locally.

## Timeline and milestones (suggested)
- Day 1: Scaffolding, config, basic server skeleton, package.json
- Day 2: Model loader and parsing tests
- Day 3: Implement search endpoint and renderer
- Day 4: Implement view details endpoint and integration tests
- Day 5: Docs, polish, and deliverables

## Deliverables
- Working TypeScript MCP Server under `src/` with two endpoints.
- `package.json`, `tsconfig.json` and test harness.
- Tests covering parser, renderer, and endpoints.
- `copilot/2.archiscribe.mcp.devplan.md` (this file).

## Next steps (immediate)
1. Scaffold project files (`package.json`, `tsconfig.json`) and add dependencies.
2. Implement `src/config` and `src/server` skeleton.
3. Implement `src/model/ModelLoader` and unit tests.

---

If any part of the plan or the assumptions should change, tell me which items to adjust and I'll update the plan and proceed to implement the first coding steps.
