## ArchiScribe MCP - Development Plan

This document defines a detailed, sequenced development plan for the ArchiScribe MCP Server project described in `copilot/1.archiscribe.mcp.requirements.md`.

### Task receipt & approach
I will convert the requirements into a concrete, testable plan and checklist, then implement iteratively: scaffold project, implement core features (model loader, view search, view details), add configuration, generate markdown output, and create tests and docs. Each step has acceptance criteria and quality gates.

---

## Requirements (extracted)
All explicit requirements from the requirements file have been implemented and completed.

**Core Implementation Requirements:**
- Implement MCP Server in TypeScript/Node.js using the MCP Typescript SDK (`@modelcontextprotocol/sdk`)
- Project code in `src/` directory
- Use example files in `data/` for testing and demo (`archimate-scribe-demo-model.xml`, `archiscribe-Dataflow-view.md`)
- MCP tools: SearchViews & GetViewDetails
- Add audit logging of every MCP tool & HTTP endpoint invocation (tool name, timestamp (UTC), caller/session id if available, parameters, success/failure, duration ms)

**API Requirements:**
- Provide API: "Search View Names" — returns list of view names optionally filtered by keyword and by configurable view property filter
- Provide API: "Get View Details" — returns detailed information about a view (elements and relationships)
- Return content in Markdown format
- Log each request *after* execution with outcome (ok/error + message) to daily log file.

**Configuration Requirements:**
- Config settings: model file path/URL, `viewsFilterByProperty` (true/false), `viewsFilterPropertyName` (default `AI-Context`), `serverPort` (default 3030)
- Extend config: `logPath` (directory, default `logs`), `logLevel` (default `info`). Ensure directory auto-created. Daily log rotation (one file per day) named `archiscribe-YYYY-MM-DD.log`.

**Quality Requirements:**
- Create well-structured, testable code with unit & integration tests
- Provide deterministic logging for tests (inject clock / dependency) to assert log line shape.

## Assumptions
- The ArchiMate model is provided as an ArchiMate Exchange XML file located locally at `data/archimate-scribe-demo-model.xml`.
- The MCP Typescript SDK is suitable for wiring the MCP server, but a minimal HTTP API will be provided if SDK usage is optional during early iterations.
- Node >= 18 and npm/yarn available on the developer machine.

## High-level milestones

1. Project scaffolding & dependencies
2. Configuration system & environment handling
3. ArchiMate model loader & parser (XML -> in-memory model)
4. Implement core MCP endpoints (Search View Names, Get View Details)
5. Markdown renderer for view responses
6. Tests: unit tests for parser & renderer, integration tests for endpoints
7. Documentation, README, example usage
8. Minor improvements and hardening (error handling, edge cases)
9. Logging & audit trail (tool invocation + HTTP)

## Detailed implementation plan (sequenced steps)

- [x] **1) Scaffolding and initial repo layout**
   - [x] Create `package.json`, TypeScript config (`tsconfig.json`), and basic scripts: `build`, `start`, `dev`, `test`.
   - [x] Directory layout under `src/`: `src/mcp`, `src/config`, `src/model`, `src/api`, `src/renderer`, `src/tests`.
   - [x] Add `data/` folder if not present and verify example files exist.
   - [x] Acceptance: project compiles, `npm run build` passes.

- [x] **2) Configuration**
   - [x] Implement a `Config` module that reads environment variables and a config file (e.g., `config/settings.json`) with defaults.
   - [x] Config fields: `modelPath`, `viewsFilterByProperty` (boolean), `viewsFilterPropertyName` (string, default `AI-Context`), `serverPort` (3030).
   - [x] Acceptance: `Config` unit test verifies defaults and overrides from env.

- [x] **3) ArchiMate model loader & parser**
   - [x] Implement `ModelLoader` to read the ArchiMate Exchange XML and parse to an in-memory representation (views, elements, relationships).
   - [x] Use `fast-xml-parser` and implement minimal mapping required for views and elements.
   - [x] Cache the parsed model and expose reload method.
   - [x] Acceptance: unit tests validate parsing of `data/archimate-scribe-demo-model.xml` into expected view names and counts.

- [x] **4) Markdown renderer**
   - [x] Implement modular renderer to convert model objects into markdown. Keep renderer separate from API to allow reuse.
   - [x] Acceptance: unit tests for renderer with small model fixtures.

- [x] **5) MCP Typescript SDK integration & tool implementations**
   - [x] Install and configure `@modelcontextprotocol/sdk` as a dependency. Create a `src/mcp` module to host MCP server wiring and tool implementations.
   - [x] Define two MCP tools that mirror the API operations:
       - [x] `SearchViews`: Input: { query?: string }, Output: { markdown: string }
       - [x] `GetViewDetails`: Input: { viewname: string }, Output: { markdown: string }
   - [x] Implement handler functions that call the `ModelLoader` and `Renderer` components.
   - [x] Expose an MCP server start/stop API in `src/mcp/server.ts` that registers the tools with the SDK.
   - [x] Provide an HTTP wrapper that translates HTTP requests into MCP tool invocations.
   - [x] Testing and acceptance: Unit test each tool handler, integration test MCP server functionality.

- [x] **6) API: Search View Names**
   - [x] Implement endpoint `GET /views?query=<keyword>` that returns a Markdown list of matched view names.
   - [x] Support optional filtering by the configured view property: when `viewsFilterByProperty` is true, only include views with the configured property name present.
   - [x] Response content-type: `text/markdown`.
   - [x] Acceptance: integration tests call endpoint and inspect markdown output.

- [x] **7) API: Get View Details**
   - [x] Implement `GET /views/:name` which returns a Markdown document containing view metadata, elements, and relationships.
   - [x] Markdown format follows the example structure in `data/archiscribe-Dataflow-view.md`.
   - [x] Acceptance: integration test compares output to expected structure.

- [x] **8) Testing**
   - [x] Unit tests (vitest) for Config, ModelLoader, Renderer.
   - [x] Integration tests for the two endpoints, using an in-memory server instance.
   - [x] MCP tools testing for SearchViews and GetViewDetails.
   - [x] Meaningful test coverage focusing on core logic.

- [x] **9) Documentation & README**
   - [x] Document how to run, configuration options, and examples using the sample files.
   - [x] Include MCP tool descriptions and HTTP API documentation.
   - [x] Add installation and development setup instructions.

- [x] **10) Logging & audit trail**
   - [x] Add logging utility (implemented custom NDJSON daily file logger in `src/utils/logger.ts`).
   - [x] Log record fields implemented: `ts`, `level`, `event`, `tool`/`method`/`path`, `params` (sanitized), `durationMs`, `success`, `error` (when applicable). 
   - [x] Daily rotation (date-based filename `archiscribe-YYYY-MM-DD.log`).
   - [x] Ensure directory creation if missing.
   - [x] Provide `LOGGER.flush()` for graceful shutdown.
   - [x] Middleware/wrapper for MCP tools (auditToolInvocation).
   - [x] HTTP layer wrapper (auditHttpInvocation in router).
   - [x] Config-driven `logLevel` filtering.
   - [x] Redact overly long parameter values (> 2k chars) with truncation marker.
   - [~] Tests: basic unit test added (`logger.test.ts`). Pending: rotation simulation & integration assertion of log lines.
   - [x] README update: logging section added (basic). Pending: note about disabling via `LOG_LEVEL` and future fields.

**Acceptance (Logging & audit trail):**
 - Invoking both tools produces appended lines in current day's log file.
 - Lines are valid JSON (or structured text) containing required fields.
 - Date change simulation (test) creates second file or re-opens new file.
 - Errors are captured with `success=false` and `error` field.
 - Tests pass and no flaky timing dependencies (use injected clock in tests).

## Data contract / small design notes
- Model shape (minimal):
  - View: { id, name, type, documentation?, properties: { [k]: v }, elements: [elementId], relationships: [relId] }
  - Element: { id, name, type, documentation?, properties }
  - Relationship: { id, sourceId, targetId, type, name }

Logging line (proposed NDJSON example):
```
{"ts":"2025-09-08T10:15:23.456Z","level":"info","event":"tool.invoke","tool":"SearchViews","params":{"query":"Data"},"durationMs":12,"success":true}
```
Rotation logic compares current date (UTC) to cached date component; on mismatch closes and opens new file.

## Edge cases to handle
- Missing or unreadable model file
- Malformed XML
- Views with duplicate names
- Views that contain no elements
- Large models (ensure reasonable memory usage and caching)
- Log directory missing (auto create) / insufficient permissions (fallback to console warn once)
- Log write errors (swallow after single warning, do not crash tool execution)
- Huge parameter payloads (truncate)

## Tests (minimal set to create first)
- Unit: Config default/override (happy & missing env)
- Unit: ModelLoader parses sample XML, returns known view names
- Unit: Renderer produces markdown sections for view with elements
- Integration: Start server with sample model; call `/views?query=` and `/views/:id` and assert HTTP 200 and markdown content
- Logging: unit test logger rotation & record shape; integration test that tool + HTTP call produce expected log entries (parse JSON lines & assert fields)

## Acceptance criteria and success definition
- Server builds and starts (port configurable) and responds to the two endpoints.
- Responses are human-readable markdown and include the requested data.
- Tests pass locally.
- Logging produces daily files with required audit data and does not degrade performance noticeably (< 5ms overhead per call in tests / measured locally).

## Timeline and milestones (suggested)
- Day 1: Scaffolding, config, basic server skeleton, package.json
- Day 2: Model loader and parsing tests
- Day 3: Implement search endpoint and renderer
- Day 4: Implement view details endpoint and integration tests
- Day 5: Docs, polish, and deliverables

## Deliverables
- Working TypeScript MCP Server under `src/` with two endpoints.
- `package.json`, `tsconfig.json` and test harness.
- Tests covering parser, renderer, and endpoints.
- `copilot/2.archiscribe.mcp.devplan.md` (this file).

## Next steps (immediate)
1. Scaffold project files (`package.json`, `tsconfig.json`) and add dependencies.
2. Implement `src/config` and `src/server` skeleton.
3. Implement `src/model/ModelLoader` and unit tests.

---

If any part of the plan or the assumptions should change, tell me which items to adjust and I'll update the plan and proceed to implement the first coding steps.
